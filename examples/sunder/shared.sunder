import "c";
import "nbnet";
import "std";

# TODO: These events are specified eith `#define`s or via anonymous enums.
# Make sure that they are eventually parsed and added to nbnet.sunder.

let NBN_NO_EVENT: sint = 0;
let NBN_SKIP_EVENT: sint = 1;

let NBN_CONNECTED: sint = 2;
let NBN_DISCONNECTED: sint = 3;
let NBN_MESSAGE_RECEIVED: sint = 4;

let NBN_NEW_CONNECTION: sint = 2;
let NBN_CLIENT_DISCONNECTED: sint = 3;
let NBN_CLIENT_MESSAGE_RECEIVED: sint = 4;

extern func usleep(usec: uint) sint;
extern func NBN_Driver_Init() void;

let NAME = startof("example");
let ADDR = startof("127.0.0.1");
let PORT = 31415u16;
let TICK_RATE = 2u; # ticks per second
let BUSY_CODE = (:sint)42;

struct message {
    let TYPE = 0u8;
    let LENGTH = 255u;

    var length: uint;
    var data: [LENGTH]char;

    func create() *message {
        return std::new[[message]]();
    }

    func destroy(self: *message) void {
        std::delete[[message]](self);
    }

    func serialize(self: *message, stream: *NBN_Stream) sint {
        # TODO: Calling custom C functions wrapping the NBN_Serialize* macros
        # fails to properly serialize a message for some unknown reason.
        # However, directly calling the stream->serialize_*_func functions will
        # successfully serialize that message. Investigate why the custom C
        # functions wrapping the serialization macros behave differently than
        # directly calling the stream's serialization functions.
        stream.*.serialize_uint_func(stream, &self.*.length, 0, (:uint)LENGTH);
        stream.*.serialize_bytes_func(stream, (:*u8)&self.*.data[0], self.*.length);
        return 0;
    }
}
